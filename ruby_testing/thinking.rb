# apparently "let" and "subject" are mostly the same?
# except "let" doesn't allow implicit calls, which i don't like anyways.
# what were the other equivalents again? "context" and "it"? wasn't there a third here? are these identical too or is there some catch like there's always some catch? well we'll just stick to the same thing.
# but the main thing here was
    let(:thing) { block }
# would also be equivalent to
    subject(:thing) { block }
# wouldn't allow it {should be (something)} stuff though.

# ah, calling explicit vs implicit is different. which is different from define ex/imp.
# from caesar cipher which has now been modified,
# implicit:
    subject { Cipher.new.caesar(text,shift) }
    context "shift +1" do
        let(:text) {"example"}; let(:shift) {1}
        it {should eql "fybnqmf"}
    end
# explicit:
    subject(:cipher) { Cipher.new.caesar(text,shift) }
    context "shift +1" do
        let(:text) {"example"}; let(:shift) {1}
        it "shifts by 1" do
            expect(cipher).to eql "fybnqmf"
        end
    end
# oh thats not entirely parallel.
# this
    it "shifts by 1" do
        expect(cipher).to eql "fybnqmf"
    end
# and
    it { expect(cipher).to eql "fybnqmf" }
# are identical, except for the message you want to print to console.
# which is probably the most important thing, this would be second.


# oh, "xit" is a built-in holder in rspec, it appears.


# lol some of this shit is a joke
# comments are in the files themselves with triple #'s for differentiation, here would be too cluttered.


    # 'eq' checks for equal VALUE.
    # 'eql' checks for equal VALUE and TYPE.
    # 'equal' checks for OBJECT IDENTITY.
    # 'be' checks for OBJECT IDENTITY.
# eeeeee

# i think i should be paying more attention to how describe/context/it is structured more than this other stuff being pointed at.


# ...what is [respond_to]?


# not sure i entirely grasp implications of "shared_examples".


# ""A-A-A"" is stupid.
# "you can disable [thing that's supposed to make life more convenient but doesn't] by adding a [convenience] file" in other words, it's a scam.
# "When you start working on a existing code base, you will often become familiar with the code by reading the tests" oh my god


    # "rbenv: version `ruby-2.7.0' is not installed (set by [..]/ruby_testing/.ruby-version)"
# what does this mean? why is this here?
# this isn't an autogenerated file? not one that i have anywhere.
# i have 2.7.0p0. i'm going to delete this.


    # "A heredoc is a way to define a multiline string, while maintaining the original indentation & formatting."
# well that's super useful.


    # describe -> Name of the method that is being tested.
    # context ->  Explains the conditions of the test.
    # it ->       Explains the results of the test.


# 13 compares a "ImpossibleToTestGame" to a "NumberGame".
# it is actually comparing a "ImpossibleToTestGame" to a "ImpossibleToReadGame".

# ...the difficulty hiked up so fast it's almost like the past 5 lessons were wasting my time.
# ...so up til now, everything has been
    expect().to eq/be/have
# there was also match { |block| block logic } but put aside for now.
# now we have
    allow().to receive().and_return()
    expect().to receive().with()
# i did not notice until now, but [expect] is now chained with two additional things that are executions and not matchers.
    # [allow(subject).receive(method).and_return(input)]
# is a mock method: it passes [input] to [subject] when it calls [method], instead of actually calling [method].
# Act = expect()
    # [expect(subject).receive(method).with(message)]
# is... who knows what: it executes [subject] and expects the execution of [method] to return [message].
    # ....what? is that the reading? why wouldn't it be called
        allow().to receive().with()
        expect().to receive().and_return()
    # instead? wouldn't that be actually what happens?
        # oh i get it. it's a matter of which is seen as subject vs object.
# putting Assert before Act makes a "Message Expectaton".
# or so it says.
# on third or fourth pass, the official docs seem to say "Message Expectation is"
    expect().to receive()
# which requires (is not a choice) to have the call to come after it. does it not call the thing itself then..?
# ...so on top of three new ideas, there's a fourth complication, namely, that this is a loop. which has not existed in any of the example scripts up til this point, i think.
# meaning, whoever thought it was a good idea to do all of these at the same time clearly wants to imprint on the audience that isolating things to make them clear and readable is a good idea.
# and is also an idiot, but that's a more minor point.
# my face hurts.

# i don't get why
    expect(game_loop).to receive(:puts).with('Input error!').twice
    game_loop.player_turn
# can't be replaced with
    expect(game_loop.player_turn).to receive(:puts).with('Input error!').twice
# ...? now that i think about it, why are we working on the class level?
# everything so far has been [expect(subject.method)], and this is suddenly on [expect(subject)] + [execute subject.method].

# actually i think i'm gonna stop thinking about this. (at least) five new concepts means (at least) five new dimensions means (at least) five new tests, which is not going to be found in the (exactly) one test given.


# 14
    # "One important
    # TDD technique is using a 'double' for any object outside of the class being
    # tested."
# this is sensible.
    # Note: the 'RandomNumber' class has not been written. During TDD, we will need
    # to create a double for RandomNumber in the tests for FindNumber.
# ...? so double any object [...] that you intend to write, right? imagine doubling a [puts]. well, i will assume what makes sense.

    name = double("comment", :foo => 1)
    allow(name).to receive(:bar) { 2 }
    expect(name.foo).to eq 1
    expect(name.bar).to eq 2
# "'double` is not available on an example group (e.g. a `describe` or `context` block). It is only available from within individual examples (e.g. `it` blocks) or from constructs that run in the scope of an example (e.g. `before`, `let`, etc)."


# 15
# what is "before" for again?
    # "RSpec will call (execute) this block before each one of the tests (examples):"
# versus let..?
    # "RSpec comes with another feature to help with this: the method let allows us to define such bits of data (or more precisely, objects) that need to be specified per context. Hereâ€™s how that looks like:"
# .......
# oh here's the one i was looking for. lucky me. no thanks to the garbage arrangement of the thing itself. 13 [159]:
    # As the 'Arrange' step for tests grows, you can use a before hook to
    # separate the test from the set-up.
    # https://relishapp.com/rspec/rspec-core/v/2-0/docs/hooks/before-and-after-hooks\
    # https://www.tutorialspoint.com/rspec/rspec_hooks.htm
        ### i'm not gonna fucking remember any of this. "read hundreds of words of official docuemntation for an entirely new concept every three lines of code!" no.
# so is [before] with no specification a [before(:each)] or a [before(:all)]? what's a "before suite"? oh no explanation.

    describe do
        subject(:stuff)
        before do
            thing = a
        end
        context do
            it do
                expect(stuff.method(thing)).to eq something_else
            end
        end
    end
# apparently [thing] is not defined here.
# this is so tiresome.
        before do
            let(:thing) { a }
        end
    # "`let` is not available from within an example (e.g. an `it` block) or from constructs that run in the scope of an example (e.g. `before`, `let`, etc). It is only available on an example group (e.g. a `describe` or `context` block)."
# running in circles already.
# i can't put arbitrary puts in RSPEC. how annoying.
# so here in [verify_input] it has to be an integer, but previously in [player_input] it has to be a string. how asinine. if you're keeping track of all this stuff anyway you might as well do it manually.
# well found what to do here at least.
    describe do
        subject(:stuff)
        let(:thing) { a }
        context do
            it do
                expect(stuff.method(thing)).to eq something_else
            end
        end
    end

# #update_random_number:
  before do
    allow(game_update).to receive(:puts)
    new_number = 76
    allow(game_update).to receive(:player_input).with(1, 100).and_return(new_number)
  end
# what the fuck is this? a receive with nothing, and then a receive with two commands?
# like okay, chaining works as long as it's passed the right type of object, but what the fuck is being passed between these? like we already know that [expect().to receive] does something entirely different to [expect().to eq]. or maybe it's not BUT NO ONE IS EXPLAINING IT.
# i expect the first to be nil, but don't know why it's there.
        # [allow(subject).receive(method).and_return(input)]
    # is a mock method: it passes [input] to [subject] when it calls [method], instead of actually calling [method].
# okay... and... [.and_return(new_number)] makes the line return [new_number]....?
  it 'sends update_value to random_number' do
    expect(random_update).to receive(:update_value).with(76)
    game_update.update_random_number
  end
# ......
# ...
    allow(game_update).to receive(:puts)
# this removes the puts from the RSPEC output.
    expect(random_update).to receive(:update_value).with(76)
# this is the thing we want to happen. "Assert". what a wrong name.
    game_update.update_random_number
# this is not executed "before"
    allow(game_update).to receive(:player_input).with(1, 100).and_return(new_number)
# which should just the same line except extended and put somewhere else.
# allow(instance) to substitute any calls to (:player_input) with (1, 100) and instead of calling (:player_input), return the value assigned at (new_number)
# that would be nice. if that's what it meant. i have no idea if that's what it means because It's That Easy [link to some documentation].
# i feel like ive been here before. i'm clearly not catching on.

# #create_binary_search:
    subject(:game_create) { described_class.new(1, 10, number_create) }
    let(:number_create) { instance_double(RandomNumber) }

    it 'creates a new BinarySearch with RandomNumber double' do
        expect(BinarySearch).to receive(:new).with(1, 10, number_create)
        game_create.create_binary_search
    end
# ...
        # [expect(subject).receive(method).with(message)]
    # is... who knows what: it executes [subject] and expects the execution of [method] to return [message].
# ....
# BinarySearch is a class. a class that is referred to directly by name (capitalized). this is the first time we are seeing something like this. why?
# actually, fuck it. even outside of this problem it doesn't line up with what we thought this syntax meant. expect/receive/with should be testing an output. here it is expecting (new) to output its inputs. which is not my understanding of what happens.


# 15 round 2
# it's been some time. i don't remember anything.
# #display_turn_order
# these instructions are clearly bad. i remember loop examples only test end conditions, and this isn't a loop anyway.
# "command" and "outgoing". can i get it working by looking at the same labels?
# "before" is for organization purposes, except it also has some other fiddly stuff which i believe we never figured out. "method stubs" should mean stuff we put in place so we only execute the method being tested.
# "command" seems to be the simple type. no examples, plus seems intuitive.
# "outgoing command" seems to be message expectations.
    # expect [Class?] to receive [method] with [thing we would expect]
    # execute method
# @guess_count has no attr_reader... i feel like i ran into this before, but i dont remember the solution.
    expect(search).to receive(:make_guess).with(no_args)
    ### with what? there's no arguments.
    ### google gods say some guy's blog says "with(no_args)" is a thing.
    turn_display.display_turn_order(search)
# apparently you can just omit the "with(no_args)" completely and it works? maybe?
    allow(turn_display).to receive(:display_guess)
# breaks without this? hm?
# without a mock/stub/whatever, the real display_guess gets called on the fake binary_search. i see.
# i don't see how we retrieve guess_count without attr_reader or something stupid like retrieving it from display_guess's console output. so it's either putting it in the thing itself, or refusing to do the test. i suppose we'll do the former.