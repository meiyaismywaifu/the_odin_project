# apparently "let" and "subject" are mostly the same?
# except "let" doesn't allow implicit calls, which i don't like anyways.
# what were the other equivalents again? "context" and "it"? wasn't there a third here? are these identical too or is there some catch like there's always some catch? well we'll just stick to the same thing.
# but the main thing here was
    let(:thing) { block }
# would also be equivalent to
    subject(:thing) { block }
# wouldn't allow it {should be (something)} stuff though.

# ah, calling explicit vs implicit is different. which is different from define ex/imp.
# from caesar cipher which has now been modified,
# implicit:
    subject { Cipher.new.caesar(text,shift) }
    context "shift +1" do
        let(:text) {"example"}; let(:shift) {1}
        it {should eql "fybnqmf"}
    end
# explicit:
    subject(:cipher) { Cipher.new.caesar(text,shift) }
    context "shift +1" do
        let(:text) {"example"}; let(:shift) {1}
        it "shifts by 1" do
            expect(cipher).to eql "fybnqmf"
        end
    end
# oh thats not entirely parallel.
# this
    it "shifts by 1" do
        expect(cipher).to eql "fybnqmf"
    end
# and
    it { expect(cipher).to eql "fybnqmf" }
# are identical, except for the message you want to print to console.
# which is probably the most important thing, this would be second.


# oh, "xit" is a built-in holder in rspec, it appears.


# lol some of this shit is a joke
# comments are in the files themselves with triple #'s for differentiation, here would be too cluttered.


    # 'eq' checks for equal VALUE.
    # 'eql' checks for equal VALUE and TYPE.
    # 'equal' checks for OBJECT IDENTITY.
    # 'be' checks for OBJECT IDENTITY.
# eeeeee

# i think i should be paying more attention to how describe/context/it is structured more than this other stuff being pointed at.


# ...what is [respond_to]?


# not sure i entirely grasp implications of "shared_examples".


# ""A-A-A"" is stupid.
# "you can disable [thing that's supposed to make life more convenient but doesn't] by adding a [convenience] file" in other words, it's a scam.
# "When you start working on a existing code base, you will often become familiar with the code by reading the tests" oh my god


    # "rbenv: version `ruby-2.7.0' is not installed (set by [..]/ruby_testing/.ruby-version)"
# what does this mean? why is this here?
# this isn't an autogenerated file? not one that i have anywhere.
# i have 2.7.0p0. i'm going to delete this.


    # "A heredoc is a way to define a multiline string, while maintaining the original indentation & formatting."
# well that's super useful.


    # describe -> Name of the method that is being tested.
    # context ->  Explains the conditions of the test.
    # it ->       Explains the results of the test.


# 13 compares a "ImpossibleToTestGame" to a "NumberGame".
# it is actually comparing a "ImpossibleToTestGame" to a "ImpossibleToReadGame".

# ...the difficulty hiked up so fast it's almost like the past 5 lessons were wasting my time.
# ...so up til now, everything has been
    expect().to eq/be/have
# there was also match { |block| block logic } but put aside for now.
# now we have
    allow().to receive().and_return()
    expect().to receive().with()
# i did not notice until now, but [expect] is now chained with two additional things that are executions and not matchers.
    # [allow(subject).receive(method).and_return(input)]
# is a mock method: it passes [input] to [subject] when it calls [method], instead of actually calling [method].
# Act = expect()
    # [expect(subject).receive(method).with(message)]
# is... who knows what: it executes [subject] and expects the execution of [method] to return [message].
    # ....what? is that the reading? why wouldn't it be called
        allow().to receive().with()
        expect().to receive().and_return()
    # instead? wouldn't that be actually what happens?
        # oh i get it. it's a matter of which is seen as subject vs object.
# putting Assert before Act makes a "Message Expectaton".
# or so it says.
# on third or fourth pass, the official docs seem to say "Message Expectation is"
    expect().to receive()
# which requires (is not a choice) to have the call to come after it. does it not call the thing itself then..?
# ...so on top of three new ideas, there's a fourth complication, namely, that this is a loop. which has not existed in any of the example scripts up til this point, i think.
# meaning, whoever thought it was a good idea to do all of these at the same time clearly wants to imprint on the audience that isolating things to make them clear and readable is a good idea.
# and is also an idiot, but that's a more minor point.
# my face hurts.

# i don't get why
    expect(game_loop).to receive(:puts).with('Input error!').twice
    game_loop.player_turn
# can't be replaced with
    expect(game_loop.player_turn).to receive(:puts).with('Input error!').twice
# ...? now that i think about it, why are we working on the class level?
# everything so far has been [expect(subject.method)], and this is suddenly on [expect(subject)] + [execute subject.method].

# actually i think i'm gonna stop thinking about this. (at least) five new concepts means (at least) five new dimensions means (at least) five new tests, which is not going to be found in the (exactly) one test given.


# 14
    # "One important
    # TDD technique is using a 'double' for any object outside of the class being
    # tested."
# this is sensible.
    # Note: the 'RandomNumber' class has not been written. During TDD, we will need
    # to create a double for RandomNumber in the tests for FindNumber.
# ...? so double any object [...] that you intend to write, right? imagine doubling a [puts]. well, i will assume what makes sense.